/*
 * Tx Sitter
 *
 * A transaction relayer service!  ## Operating a relayer Below is a guide on using this service. Note that septs 1 through 4 require authentication using HTTP Basic auth. Using swagger explorer make sure to click the authorize button and use the correct credentials. Default dev creds are `admin:admin`.  ### 1. Setup a network tx-sitter keeps track of supported networks in its internal database. In order to be able to create any relayers at least one network must be present. To add a network use the `POST /1/admin/networks/:chain_id` endpoint.  To see the list of currently added networks use the `GET /1/admin/networks` endpoint.  ### 2. Create a relayer A relayer is an abstraction layer on top of a private key stored locally (for testing purposes only!) or using a secrets manager (currently only AWS KMS is supported).  To create a relayer use the `POST /1/admin/relayer` endpoint. The data returned will contain a relayer id, make sure to copy it to the clipboard.  ### 3. Create an API key By itself a relayer is not very useful. In order to send transactions one must create an API key. To do that use the `POST /1/admin/relayer/:relayer_id/key` endpoint. **Make sure to copy the API key from the response. It's not possible to recover it!** But it's always possible to create a new one.  ### 4. Use the API key Once an API keys has been created it's possible to use the relayer api to, among other things, send transactions.  You can use the `POST /1/api/:api_token/tx` endpoint to create a transaction. 
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_network`]
#[derive(Clone, Debug)]
pub struct CreateNetworkParams {
    pub chain_id: i32,
    pub new_network_info: models::NewNetworkInfo
}

/// struct for passing parameters to the method [`create_relayer`]
#[derive(Clone, Debug)]
pub struct CreateRelayerParams {
    pub create_relayer_request: models::CreateRelayerRequest
}

/// struct for passing parameters to the method [`get_relayer`]
#[derive(Clone, Debug)]
pub struct GetRelayerParams {
    pub relayer_id: String
}

/// struct for passing parameters to the method [`relayer_create_api_key`]
#[derive(Clone, Debug)]
pub struct RelayerCreateApiKeyParams {
    pub relayer_id: String
}

/// struct for passing parameters to the method [`reset_relayer`]
#[derive(Clone, Debug)]
pub struct ResetRelayerParams {
    pub relayer_id: String
}

/// struct for passing parameters to the method [`update_relayer`]
#[derive(Clone, Debug)]
pub struct UpdateRelayerParams {
    pub relayer_id: String,
    pub relayer_update: models::RelayerUpdate
}


/// struct for typed errors of method [`create_network`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateNetworkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_relayer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRelayerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_networks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNetworksError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_relayer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelayerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_relayers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRelayersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`relayer_create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RelayerCreateApiKeyError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_relayer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetRelayerError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_relayer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRelayerError {
    UnknownValue(serde_json::Value),
}


pub async fn create_network(configuration: &configuration::Configuration, params: CreateNetworkParams) -> Result<(), Error<CreateNetworkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let chain_id = params.chain_id;
    let new_network_info = params.new_network_info;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/network/{chain_id}", local_var_configuration.base_path, chain_id=chain_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&new_network_info);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CreateNetworkError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_relayer(configuration: &configuration::Configuration, params: CreateRelayerParams) -> Result<models::CreateRelayerResponse, Error<CreateRelayerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_relayer_request = params.create_relayer_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/relayer", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_relayer_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateRelayerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_networks(configuration: &configuration::Configuration) -> Result<Vec<models::NetworkInfo>, Error<GetNetworksError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/networks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetNetworksError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_relayer(configuration: &configuration::Configuration, params: GetRelayerParams) -> Result<models::RelayerInfo, Error<GetRelayerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let relayer_id = params.relayer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/relayer/{relayer_id}", local_var_configuration.base_path, relayer_id=crate::apis::urlencode(relayer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRelayerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn get_relayers(configuration: &configuration::Configuration) -> Result<Vec<models::RelayerInfo>, Error<GetRelayersError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/relayers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRelayersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn relayer_create_api_key(configuration: &configuration::Configuration, params: RelayerCreateApiKeyParams) -> Result<models::CreateApiKeyResponse, Error<RelayerCreateApiKeyError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let relayer_id = params.relayer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/relayer/{relayer_id}/key", local_var_configuration.base_path, relayer_id=crate::apis::urlencode(relayer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RelayerCreateApiKeyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Purges unsent transactions, useful for unstucking the relayer
pub async fn reset_relayer(configuration: &configuration::Configuration, params: ResetRelayerParams) -> Result<(), Error<ResetRelayerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let relayer_id = params.relayer_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/relayer/{relayer_id}/reset", local_var_configuration.base_path, relayer_id=crate::apis::urlencode(relayer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ResetRelayerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_relayer(configuration: &configuration::Configuration, params: UpdateRelayerParams) -> Result<(), Error<UpdateRelayerError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let relayer_id = params.relayer_id;
    let relayer_update = params.relayer_update;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/1/admin/relayer/{relayer_id}", local_var_configuration.base_path, relayer_id=crate::apis::urlencode(relayer_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_auth_conf) = local_var_configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(local_var_auth_conf.0.to_owned(), local_var_auth_conf.1.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&relayer_update);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UpdateRelayerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

